var documenterSearchIndex = {"docs":
[{"location":"implementing/#Implementing-loaders/savers","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"","category":"section"},{"location":"implementing/#Principle-of-operation:-module-qualification","page":"Implementing loaders/savers","title":"Principle of operation: module qualification","text":"","category":"section"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"When FileIO detects that a file or stream should be handled by a particular package, it will try to call private methods in that package for processing the request. For example, suppose you have created a package called MyFileFormat to handle files of a particular format; then load(\"somefile.myfmt\") for a suitable file will cause FileIO to:","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"attempt to load your package MyFileFormat using Base.require(id::PkgId), where a PkgId combines the name and UUID that you supplied via add_format\ncall MyFileFormat.load(file) where file is File.","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"A crucial point is that MyFileFormat.load does not extend FileIO.load: it is a private function defined in module MyFileFormat. This is important for ensuring that single formats can be supported by multiple packages; if two or more packages specialized File.load for file::File{format\"MYFORMAT\"}), then","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"using Pkg1, Pkg2   # two packages both inappropriately extending FileIO.load","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"would cause all such loads to be handled by Pkg2, but","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"using Pkg2, Pkg1","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"would cause them to be handled by Pkg1. This would make loading incredibly brittle. For that reason, it is essential to keep load private to your package and let FileIO call it by module-qualification.","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"The same applies to save, loadstreaming, and savestreaming.","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"If you run into a naming conflict with the load and save functions (for example, you already have another function in your package that has one of these names), you can instead name your loaders fileio_load, fileio_save etc. Note that you cannot mix and match these styles: either all your loaders have to be named load, or all of them should be called fileio_load, but you cannot use both conventions in one module.","category":"page"},{"location":"implementing/#All-at-once-I/O:-implementing-load-and-save","page":"Implementing loaders/savers","title":"All-at-once I/O: implementing load and save","text":"","category":"section"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"In your package, write code like the following:","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"module MyFileFormat\n\nusing FileIO\n\n# Again, this is a *private* `load` function, do not extend `FileIO.load`!\nfunction load(f::File{format\"PNG\"})\n    open(f) do s\n        skipmagic(s)  # skip over the magic bytes\n        # You can just call the `load(::Stream)` method below...\n        ret = load(s)\n        # ...or implement everything here instead\n    end\nend\n\n# You can support streams and add keywords:\nfunction load(s::Stream{format\"PNG\"}; keywords...)\n    # s is already positioned after the magic bytes\n    # Do the stuff to read a PNG file\n    chunklength = read(s, UInt32)\n    ...\nend\n\nfunction save(f::File{format\"PNG\"}, data)\n    open(f, \"w\") do s\n        # Don't forget to write the magic bytes!\n        write(s, magic(format\"PNG\"))\n        # Do the rest of the stuff needed to save in PNG format\n    end\nend\n\nend # module MyFileFormat","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"load(::File) and save(::File) should close any streams they open.  (If you use the do syntax, this happens for you automatically even if the code inside the do scope throws an error.) Conversely, load(::Stream) and save(::Stream) should not close the stream argument.","category":"page"},{"location":"implementing/#Implementing-streaming-I/O","page":"Implementing loaders/savers","title":"Implementing streaming I/O","text":"","category":"section"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"loadstreaming and savestreaming use the same query mechanism, but return a decoded stream that users can read or write. You should also implement a close method on your reader or writer type. Just like with load and save, if the user provided a filename, your close method should be responsible for closing any streams you opened in order to read or write the file. If you are given a Stream, your close method should only do the clean up for your reader or writer type, not close the stream.","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"struct WAVReader\n    io::IO\n    ownstream::Bool\nend\n\nfunction Base.read(reader::WAVReader, frames::Int)\n    # read and decode audio samples from reader.io\nend\n\nfunction Base.close(reader::WAVReader)\n    # do whatever cleanup the reader needs\n    reader.ownstream && close(reader.io)\nend\n\n# FileIO has fallback functions that make these work using `do` syntax as well,\n# and will automatically call `close` on the returned object.\nloadstreaming(f::File{format\"WAV\"}) = WAVReader(open(f), true)\nloadstreaming(s::Stream{format\"WAV\"}) = WAVReader(s, false)","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"If you choose to implement loadstreaming and savestreaming in your package, you can easily add save and load methods in the form of:","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"function save(q::Formatted{format\"WAV\"}, data, args...; kwargs...)\n    savestreaming(q, args...; kwargs...) do stream\n        write(stream, data)\n    end\nend\n\nfunction load(q::Formatted{format\"WAV\"}, args...; kwargs...)\n    loadstreaming(q, args...; kwargs...) do stream\n        read(stream)\n    end\nend","category":"page"},{"location":"implementing/","page":"Implementing loaders/savers","title":"Implementing loaders/savers","text":"where Formatted is the abstract supertype of File and Stream.","category":"page"},{"location":"registry/#Registry-table","page":"Registry table","title":"Registry table","text":"","category":"section"},{"location":"registry/","page":"Registry table","title":"Registry table","text":"The following formats are registered with FileIO:","category":"page"},{"location":"registry/","page":"Registry table","title":"Registry table","text":"Format Name extensions IO library detection or magic number\nJLD .jld loads and saves on all platforms with JLD (UInt8[0x4a, 0x75, 0x6c, 0x69, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x28, 0x48, 0x44, 0x46, 0x35, 0x29, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x30, 0x2e, 0x30], UInt8[0x4a, 0x75, 0x6c, 0x69, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x28, 0x48, 0x44, 0x46, 0x35, 0x29, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x30, 0x2e, 0x31])\nJLD2 .jld2 loads and saves on all platforms with JLD2 (UInt8[0x4a, 0x75, 0x6c, 0x69, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x28, 0x48, 0x44, 0x46, 0x35, 0x29, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x30, 0x2e, 0x32], UInt8[0x48, 0x44, 0x46, 0x35, 0x2d, 0x62, 0x61, 0x73, 0x65, 0x64, 0x20, 0x4a, 0x75, 0x6c, 0x69, 0x61, 0x20, 0x44, 0x61, 0x74, 0x61, 0x20, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20])\nBSON .bson loads and saves on all platforms with BSON only extension\nJLSO .jlso loads and saves on all platforms with JLSO only extension\nNPY .npy loads and saves on all platforms with NPZ \"\\x93NUMPY\"\nNPZ .npz loads and saves on all platforms with NPZ \"PK\\x03\\x04\"\nRData .rda, .RData, .rdata loads with RData on all platforms has detection function\nRDataSingle .rds loads with RData on all platforms has detection function\nAVSfld .fld loads and saves on all platforms with AVSfldIO \"# AVS\"\nCSV .csv loads and saves on all platforms with CSVFiles only extension\nTSV .tsv loads and saves on all platforms with CSVFiles only extension\nFeather .feather loads and saves on all platforms with FeatherFiles \"FEA1\"\nArrow .arrow loads and saves on all platforms with Arrow UInt8[0x41, 0x52, 0x52, 0x4f, 0x57, 0x31, 0x00, 0x00]\nExcel .xls, .xlsx loads and saves on all platforms with ExcelFiles only extension\nStata .dta loads with StatFiles on all platforms only extension\nSPSS .sav loads with StatFiles on all platforms \"FL2\"\nSAS .sas7bdat loads with StatFiles on all platforms UInt8[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc2, 0xea, 0x81, 0x60, 0xb3, 0x14, 0x11, 0xcf, 0xbd, 0x92, 0x08, 0x00, 0x09, 0xc7, 0x31, 0x8c, 0x18, 0x1f, 0x10, 0x11]\nParquet .parquet loads with ParquetFiles on all platforms \"PAR1\"\nPBMBinary .pbm loads and saves on all platforms with ImageIO \"P4\"\n  loads and saves on all platforms with Netpbm \n  loads and saves on all platforms with ImageMagick \nPGMBinary .pgm loads and saves on all platforms with ImageIO \"P5\"\n  loads and saves on all platforms with Netpbm \nPPMBinary .ppm loads and saves on all platforms with ImageIO \"P6\"\n  loads and saves on all platforms with Netpbm \nPBMText .pbm loads and saves on all platforms with ImageIO \"P1\"\n  loads and saves on all platforms with Netpbm \n  loads with ImageMagick on all platforms \nPGMText .pgm loads and saves on all platforms with ImageIO \"P2\"\n  loads and saves on all platforms with Netpbm \n  loads with ImageMagick on all platforms \nPPMText .ppm loads and saves on all platforms with ImageIO \"P3\"\n  loads and saves on all platforms with Netpbm \n  loads with ImageMagick on all platforms \nNRRD .nrrd, .nhdr loads and saves on all platforms with NRRD \"NRRD\"\nAndorSIF .sif loads with AndorSIF on all platforms \"Andor Technology Multi-Channel File\"\nFLO .flo loads and saves on all platforms with OpticalFlowUtils \"PIEH\"\nCRW .crw loads and saves on all platforms with ImageMagick UInt8[0x49, 0x49, 0x1a, 0x00, 0x00, 0x00, 0x48, 0x45]\nCUR .cur loads and saves on all platforms with ImageMagick UInt8[0x00, 0x00, 0x02, 0x00]\nDCX .dcx loads and saves on all platforms with ImageMagick UInt8[0xb1, 0x68, 0xde, 0x3a]\nDOT .dot loads and saves on all platforms with ImageMagick UInt8[0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1]\nEPS .eps loads and saves on all platforms with ImageMagick UInt8[0x25, 0x21, 0x50, 0x53, 0x2d, 0x41, 0x64, 0x6f]\n  saves with MimeWriter on all platforms \nEXR .exr loads and saves on all platforms with ImageIO UInt8[0x76, 0x2f, 0x31, 0x01]\nHDR .hdr loads and saves on all platforms with ImageMagick UInt8[0x23, 0x3f, 0x52, 0x41, 0x44, 0x49, 0x41, 0x4e]\nICO .ico loads and saves on all platforms with ImageMagick UInt8[0x00, 0x00, 0x01, 0x00]\nINFO .info loads and saves on all platforms with ImageMagick UInt8[0x7a, 0x62, 0x65, 0x78]\nJP2 .jp2 loads and saves on all platforms with ImageMagick UInt8[0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20]\n  loads and saves on all platforms with OpenCV \nPDB .pdb loads and saves on all platforms with ImageMagick UInt8[0x73, 0x7a, 0x65, 0x7a]\nPDF .pdf loads and saves on all platforms with ImageMagick UInt8[0x25, 0x50, 0x44, 0x46]\n  saves with MimeWriter on all platforms \nPGM .pgm loads and saves on all platforms with ImageMagick UInt8[0x50, 0x35, 0x0a]\nPSD .psd loads and saves on all platforms with ImageMagick UInt8[0x38, 0x42, 0x50, 0x53]\nRGB .rgb loads and saves on all platforms with ImageMagick UInt8[0x01, 0xda, 0x01, 0x01, 0x00, 0x03]\nWMF .wmf loads and saves on all platforms with ImageMagick UInt8[0xd7, 0xcd, 0xc6, 0x9a]\nWPG .wpg loads and saves on all platforms with ImageMagick UInt8[0xff, 0x57, 0x50, 0x43]\nImagine .imagine loads and saves on all platforms with ImagineFormat \"IMAGINE\"\nTGA .tga loads and saves on all platforms with ImageMagick only extension\nGIF .gif loads and saves on all platforms with ImageMagick UInt8[0x47, 0x49, 0x46, 0x38]\nPNG .png loads and saves on all platforms with ImageIO UInt8[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]\n  loads and saves on all platforms with ImageMagick \n  loads and saves on all platforms with OpenCV \n  saves with MimeWriter on all platforms \nJPEG .jpeg, .jpg, .JPG loads and saves on all platforms with JpegTurbo UInt8[0xff, 0xd8, 0xff]\n  loads and saves on all platforms with ImageIO \n  loads and saves on all platforms with ImageMagick \n  loads and saves on all platforms with OpenCV \nBMP .bmp loads and saves on all platforms with ImageMagick UInt8[0x42, 0x4d]\n  loads and saves on all platforms with OpenCV \nPCX .pcx loads and saves on all platforms with ImageMagick (UInt8[0x0a, 0x02], UInt8[0x0a, 0x05])\nQOI .qoi loads and saves on all platforms with QOI \"qoif\"\n  loads and saves on all platforms with ImageIO \nSVG .svg saves with MimeWriter on all platforms only extension\nSIXEL .sixel, .six loads and saves on all platforms with Sixel UInt8[0x1b, 0x50, 0x71]\n  loads and saves on all platforms with ImageIO \n  loads and saves on all platforms with ImageMagick \nWebP .webp loads and saves on all platforms with WebP has detection function\n  loads and saves on all platforms with ImageIO \nAVI .avi loads and saves on all platforms with ImageMagick has detection function\n  loads and saves on all platforms with VideoIO \nMP4 .mp4 loads and saves on all platforms with VideoIO has detection function\nOGG .ogg, .ogv loads and saves on all platforms with VideoIO UInt8[0x4f, 0x67, 0x67, 0x53]\n  loads and saves on all platforms with LibSndFile \nMATROSKA .mkv, .mks, .webm loads and saves on all platforms with VideoIO UInt8[0x1a, 0x45, 0xdf, 0xa3]\nOBJ .obj loads and saves on all platforms with MeshIO only extension\nPLY_ASCII .ply loads and saves on all platforms with MeshIO \"ply\\nformat ascii 1.0\"\nPLY_BINARY .ply loads and saves on all platforms with MeshIO \"ply\\nformat binary_little_endian 1.0\"\n2DM .2dm loads and saves on all platforms with MeshIO \"MESH2D\"\nOFF .off loads and saves on all platforms with MeshIO \"OFF\"\nMSH .msh loads and saves on all platforms with MeshIO only extension\nOUT .out loads and saves on all platforms with BundlerIO \"# Bundle file v0.3\\n\"\nGSLIB .gslib, .sgems loads and saves on all platforms with GslibIO only extension\nWAV .wav loads and saves on all platforms with WAV has detection function\n  loads and saves on all platforms with LibSndFile \nFLAC .flac loads and saves on all platforms with FLAC \"fLaC\"\n  loads and saves on all platforms with LibSndFile \nJLPROF .jlprof loads and saves on all platforms with FlameGraphs UInt8[0x4a, 0x4c, 0x50, 0x52, 0x4f, 0x46, 0x01, 0x00]\nbedGraph .bedgraph loads and saves on all platforms with BedgraphFiles has detection function\nTIFF .tiff, .tif loads and saves on all platforms with ImageIO has detection function\n  loads and saves on all platforms with ImageMagick \n  loads and saves on all platforms with OpenCV \nOMETIFF .tif, .tiff loads and saves on all platforms with OMETIFF has detection function\nDCM .dcm loads and saves on all platforms with ImageMagick has detection function\nh5mu .h5mu loads and saves on all platforms with Muon has detection function\nHDF5 .h5, .hdf5 loads and saves on all platforms with HDF5 has detection function\nh5ad .h5ad loads and saves on all platforms with Muon has detection function\nSTL_ASCII .stl, .STL loads and saves on all platforms with MeshIO has detection function\nSTL_BINARY .stl, .STL loads and saves on all platforms with MeshIO has detection function\nGZIP .gz loads and saves on all platforms with Libz has detection function\nFITS .fit, .fits, .fts, .FIT, .FITS, .FTS, .fit loads and saves on all platforms with FITSIO has detection function\n  loads and saves on all platforms with AstroImages \nGadget2 .gadget2, .Gadget2, .GADGET2 loads and saves on all platforms with AstroIO has detection function\nRawArray .ra loads and saves on all platforms with RawArray UInt8[0x61, 0x72, 0x61, 0x77, 0x72, 0x72, 0x79, 0x61]\nMetaImage .mhd loads and saves on all platforms with MetaImageFormat \"ObjectType\"\nvegalite .vegalite loads and saves on all platforms with VegaLite only extension\nvega .vega loads and saves on all platforms with Vega only extension\n  saves with VegaLite on all platforms \nFCS .fcs loads and saves on all platforms with FCSFiles \"FCS\"\nHTML .html, .htm saves with MimeWriter on all platforms only extension\nMIDI .mid, .midi, .MID loads and saves on all platforms with MIDI \"MThd\"\nBIB .bib loads and saves on all platforms with Bibliography only extension\nSMS .sms loads and saves on all platforms with SpaSM only extension\nHOA .hoa loads and saves on all platforms with Buchi UInt8[0x48, 0x4f, 0x41, 0x3a]\nBA .ba loads and saves on all platforms with Buchi only extension","category":"page"},{"location":"world_age_issue/#World-age-issue","page":"World age issue","title":"World age issue","text":"","category":"section"},{"location":"world_age_issue/#Motivation:-lazy-loading","page":"World age issue","title":"Motivation: lazy loading","text":"","category":"section"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"The goal of FileIO is to provide a unified IO frontend so that users can easily deal with file IO with the simple load/save functions. The actual IO work will be dispatched to various IO backends. For instance, PNGFiles.jl is used to load PNG format images. If using FileIO were to load all registered IO backends, then it would be very slow to load, hurting all users of FileIO. For any given user, most of those backends would also be unnecessary – for example, people who don't do image processing probably don't want to load any thing related to image IO.","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"To avoid such unnecessary loading latency, FileIO defers package loading until it's actually used. For instance, when you use FileIO, you'll probably observe something like this:","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"julia> using TestImages, FileIO\n\njulia> path = testimage(\"cameraman\"; download_only=true)\n\"/home/jc/.julia/artifacts/27a4c26bcdd47eb717bee089ec231a899cb8ef69/cameraman.tif\"\n\njulia> load(path) # actual backend loading happens here\n[ Info: Precompiling ImageIO [82e4d734-157c-48bb-816b-45c225c6df19]\n[ Info: Precompiling TiffImages [731e570b-9d59-4bfa-96dc-6df516fadf69]\n...","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"ImageIO and TiffImages were loaded because the file in path was detected to be a TIFF image, well after FileIO was loaded into the session.","category":"page"},{"location":"world_age_issue/#The-hidden-issue","page":"World age issue","title":"The hidden issue","text":"","category":"section"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"Although this lazy-loading trick reduces the time needed for using FileIO, it isn't normal practice in Julia because it introduces a so-called world age issue or world age problem. The world age issue happens when you call methods that get compiled in a newer \"world\" (get compiled after initial compilation finishes) than the one you called them from.","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"Let's demonstrate the problem concretely. In case you don't have a suitable file to play with, let's first create one:","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"julia> using IndirectArrays, ImageCore\n\njulia> img = IndirectArray(rand(1:5, 4, 4), rand(RGB, 5))\n4×4 IndirectArray{RGB{Float64}, 2, Int64, Matrix{Int64}, Vector{RGB{Float64}}}:\n[...]\n\njulia> save(\"indexed_image.png\", img)","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"Now, reopen a new julia REPL (this is crucial for demonstrating the problem) and call load from within a function (this is also crucial):","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"julia> using FileIO\n\njulia> f() = size(load(\"indexed_image.png\"))\nf (generic function with 1 method)\n\njulia> f()\nERROR: MethodError: no method matching size(::IndirectArrays.IndirectArray{ColorTypes.RGB{FixedPointNumbers.N0f8}, 2, UInt8, Matrix{UInt8}, OffsetArrays.OffsetVector{ColorTypes.RGB{FixedPointNumbers.N0f8}, Vector{ColorTypes.RGB{FixedPointNumbers.N0f8}}}})\nThe applicable method may be too new: running in world age 32382, while current world is 32416.\nClosest candidates are:\n  size(::IndirectArrays.IndirectArray) at ~/.julia/packages/IndirectArrays/BUQO3/src/IndirectArrays.jl:52 (method too new to be called from this world context.)\n  size(::AbstractArray{T, N}, ::Any) where {T, N} at abstractarray.jl:42\n  size(::Union{LinearAlgebra.Adjoint{T, var\"#s880\"}, LinearAlgebra.Transpose{T, var\"#s880\"}} where {T, var\"#s880\"<:(AbstractVector)}) at /Applications/Julia-1.8.app/Contents/Resources/julia/share/julia/stdlib/v1.8/LinearAlgebra/src/adjtrans.jl:173\n  ...\nStacktrace:\n [1] f()\n   @ Main ./REPL[2]:1\n [2] top-level scope\n   @ REPL[3]:1","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"To understand why this happened, you have to understand the order of events:","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"When calling f() from the REPL, Julia first compiled f. Importantly, when compiling, Julia didn't know what type of object was going to be returned by load, so in the compiled code it waits to see what object actually gets returned before figuring out which method of size to call. (This is called runtime dispatch.)\nIt queried the file, recognized a PNG file, and loaded the ImageIO and PNGFiles packages. (It's for the loading of these packages that you needed to start a fresh Julia session.)\nFileIO calls the appropriate PNG-specific load function in PNGFiles. (We'll have more to say about this step further below.) This causes an image to be returned, which is an array of a type defined by the IndirectArrays package (a dependency of PNGFiles).\nf calls size on the returned image. However, this fails, because at the time you called f, the IndirectArrays package wasn't loaded.","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"In other words, size method for IndirectArray lives in a world that's newer than the one from which you called f(). This leads to the observed error.","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"note: Note\nWorld age is crucial to Julia's ability to allow you to redefine methods interactively, but the error we're illustrating is an unfortunate side-effect.","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"The good news is it's easy to fix, just try calling f() again:","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"julia> f()\n(4, 4)","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"The second f() works because this time you're calling f() in the latest world age with the necessary size(::IndirectArray) already defined. In essence, you fast-forward to the latest world with each statement you type at the REPL.","category":"page"},{"location":"world_age_issue/#Solutions","page":"World age issue","title":"Solutions","text":"","category":"section"},{"location":"world_age_issue/#Base.invokelatest","page":"World age issue","title":"Base.invokelatest","text":"","category":"section"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"One solution is to make the call to size via Base.invokelatest, which exists explicitly to work around this world-age dispatch problem. Literally, invokelatest dispatches the supplied call using the latest world age (which may be newer than when you typed f() at the REPL). In a fresh Julia session,","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"julia> using FileIO\n\njulia> f() = Base.invokelatest(size, load(\"indexed_image.png\"))\nf (generic function with 1 method)\n\njulia> f()\n(4, 4)","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"note: Note\nIn step 3 above (\"FileIO calls the appropriate PNG-specific load function in PNGFiles\"), the call to the load function defined in PNGFiles is made via invokelatest. Otherwise, even ordinary interactive usage of FileIO (without burying load inside a function) would cause world-age errors.","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"warning: Warning\nUsing invokelatest slows your code considerably. Use it only when absolutely necessary.","category":"page"},{"location":"world_age_issue/#Eagerly-load-the-required-packages-first","page":"World age issue","title":"Eagerly load the required packages first","text":"","category":"section"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"Another solution to the world age issue is simple and doesn't have long-term downsides: eagerly load the needed packages. For instance, if you're seeing world age issue complaining methods related to IndirectArray, then load IndirectArrays eagerly:","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"julia> using FileIO, IndirectArrays # try this on a new Julia REPL\n\njulia> f() = size(load(\"indexed_image.png\"))\nf (generic function with 1 method)\n\njulia> f()\n(4, 4)","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"Thus if you want to build a package, it could be something like this:","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"module MyFancyPackage\n\n# This ensures that whoever loads `MyFancyPackage`, he has IndirectArrays loaded and\n# thus avoid the world age issue.\nusing IndirectArrays, FileIO\n\nf(file) = length(load(file))\nend","category":"page"},{"location":"world_age_issue/","page":"World age issue","title":"World age issue","text":"Enjoy the FileIO and its lazy loading, but be aware that its speedy loading comes with some caveats.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [FileIO]\nPrivate = false","category":"page"},{"location":"reference/#FileIO.FileIO","page":"Reference","title":"FileIO.FileIO","text":"FileIO API (brief summary, see individual functions for more detail):\n\nformat\"PNG\": specifies a particular defined format\nFile{fmt} and Stream{fmt}: types of objects that declare that a resource has a particular format fmt\nload([filename|stream]): read data in formatted file, inferring the format\nload(File{format\"PNG\"}(filename)): specify the format manually\nloadstreaming([filename|stream]): similar to load, except that it returns an object that can be read from\nsave(filename, data...) for similar operations involving saving data\nsavestreaming([filename|stream]): similar to save, except that it returns an object that can be written to\nio = open(f::File, args...) opens a file\nio = stream(s::Stream) returns the IOStream from the query object s\nquery([filename|stream]): attempt to infer the format of filename\nunknown(q) returns true if a query can't be resolved\nskipmagic(io, fmt) sets the position of io to just after the magic bytes\nmagic(fmt) returns the magic bytes for format fmt\ninfo(fmt) returns (magic, extensions) for format fmt\nadd_format(fmt, magic, extension, libraries...): register a new format\nadd_loader(fmt, :Package): indicate that Package supports loading files of type fmt\nadd_saver(fmt, :Package): indicate that Package supports saving files of type fmt\n\n\n\n\n\n","category":"module"},{"location":"reference/#FileIO.DataFormat","page":"Reference","title":"FileIO.DataFormat","text":"DataFormat{sym}()\n\nIndicates a known binary or text format of kind sym, where sym is always a symbol. For example, a .csv file might have DataFormat{:CSV}().\n\nAn easy way to write DataFormat{:CSV} is format\"CSV\".\n\n\n\n\n\n","category":"type"},{"location":"reference/#FileIO.File","page":"Reference","title":"FileIO.File","text":"File{fmt}(filename)\n\nIndicates that filename is a file of known DataFormat fmt. For example, File{format\"PNG\"}(filename) would indicate a PNG file.\n\ncompat: Compat\nFile{fmt}(filename) requires FileIO 1.6 or higher. The deprecated syntax File(fmt, filename) works on all FileIO 1.x releases.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FileIO.Stream","page":"Reference","title":"FileIO.Stream","text":"Stream{fmt}(io, filename=nothing)\n\nIndicates that the stream io is written in known format DataFormat fmt. For example, Stream{format\"PNG\"}(io) would indicate PNG format. If known, the optional filename argument can be used to improve error messages, etc.\n\ncompat: Compat\nStream{fmt}(io, ...) requires FileIO 1.6 or higher. The deprecated syntax Stream(fmt, io, ...) works on all FileIO 1.x releases.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FileIO.add_format-Tuple{Type, Vararg{Any}}","page":"Reference","title":"FileIO.add_format","text":"add_format(fmt, magic, extension)\n\nregisters a new DataFormat.\n\nFor example:\n\nadd_format(format\"TIFF\", (UInt8[0x4d,0x4d,0x00,0x2b], UInt8[0x49,0x49,0x2a,0x00]), [\".tiff\", \".tif\"])\nadd_format(format\"PNG\", [0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a], \".png\")\nadd_format(format\"NRRD\", \"NRRD\", [\".nrrd\",\".nhdr\"])\n\nNote that extensions, magic numbers, and format-identifiers are case-sensitive.\n\nYou can also specify particular packages that support the format with add_format(fmt, magic, extension, pkgspecifiers...), where example pkgspecifiers are:\n\nadd_format(fmt, magic, extension, [:PkgA=>UUID(...)])                     # only PkgA supports the format (load & save)\nadd_format(fmt, magic, extension, [:PkgA=>uuidA], [:PkgB=>uuidB])         # try PkgA first, but if it fails try PkgB\nadd_format(fmt, magic, extension, [:PkgA=>uuidA, LOAD], [:PkgB=>uuidB])   # try PkgA first for `load`, otherwise use PkgB\nadd_format(fmt, magic, extension, [:PkgA=>uuidA, OSX], [:PkgB=>uuidB])    # use PkgA on OSX, and PkgB otherwise\n\nThe uuids are all of type UUID and can be obtained from the package's Project.toml file.\n\nYou can combine LOAD, SAVE, OSX, Unix, Windows and Linux arbitrarily to narrow pkgspecifiers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.add_loader","page":"Reference","title":"FileIO.add_loader","text":"add_loader(fmt, :Package=>uuid)\nadd_loader(fmt, [:Package=>uuid, specifiers...])\n\nDeclare that format fmt can be loaded with package :Package. Specifiers include OSX, Unix, Windows and Linux to restrict usage to particular operating systems.\n\nSee also add_format which can combine package support with the format declaration.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.add_saver","page":"Reference","title":"FileIO.add_saver","text":"add_saver(fmt, :Package=>uuid)\nadd_saver(fmt, [:Package=>uuid, specifiers...])\n\nDeclare that format fmt can be saved with package :Package. Specifiers include OSX, Unix, Windows and Linux to restrict usage to particular operating systems.\n\nSee also add_format which can combine package support with the format declaration.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.del_format-Tuple{Type}","page":"Reference","title":"FileIO.del_format","text":"del_format(fmt::DataFormat)\n\ndeletes fmt from the format registry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.file_extension-Tuple{File}","page":"Reference","title":"FileIO.file_extension","text":"file_extension(file)\n\nReturns the file extension associated with File file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.file_extension-Tuple{Stream}","page":"Reference","title":"FileIO.file_extension","text":"file_extension(file)\n\nReturns a nullable-string for the file extension associated with Stream stream.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.filename-Tuple{File}","page":"Reference","title":"FileIO.filename","text":"filename(file)\n\nReturns the filename associated with File file.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.filename-Tuple{Stream}","page":"Reference","title":"FileIO.filename","text":"filename(stream)\n\nReturns a string of the filename associated with Stream stream, or nothing if there is no file associated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.load","page":"Reference","title":"FileIO.load","text":"load(filename) loads the contents of a formatted file, trying to infer the format from filename and/or magic bytes in the file (see query).\nload(strm) loads from an IOStream or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification.\nload(File{format\"PNG\"}(filename)) specifies the format directly, and bypasses the format query.\nload(Stream{format\"PNG\"}(io)) specifies the format directly, and bypasses the format query.\nload(f; options...) passes keyword arguments on to the loader.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.loadstreaming","page":"Reference","title":"FileIO.loadstreaming","text":"Some packages may implement a streaming API, where the contents of the file can be read in chunks and processed, rather than all at once. Reading from these higher-level streams should return a formatted object, like an image or chunk of video or audio.\n\nloadstreaming(filename) loads the contents of a formatted file, trying to infer the format from filename and/or magic bytes in the file. It returns a streaming type that can be read from in chunks, rather than loading the whole contents all at once.\nloadstreaming(strm) loads the stream from an IOStream or similar object. In this case, there is no filename extension, so we rely on the magic bytes for format identification.\nloadstreaming(File{format\"WAV\"}(filename)) specifies the format directly, and bypasses the format query.\nloadstreaming(Stream{format\"WAV\"}(io)) specifies the format directly, and bypasses the format query.\nloadstreaming(f; options...) passes keyword arguments on to the loader.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.magic-Tuple{Type}","page":"Reference","title":"FileIO.magic","text":"magic(fmt)\n\nReturns the magic bytes of format fmt\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.query","page":"Reference","title":"FileIO.query","text":"query(io, [filename])\n\nReturns a Stream object with information about the format inferred from the magic bytes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.query-Tuple{Any}","page":"Reference","title":"FileIO.query","text":"query(filename; checkfile=true)\n\nReturn a File object with information about the format inferred from the file's extension and/or magic bytes. If filename already exists, the file's magic bytes will take priority unless checkfile is false.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.save","page":"Reference","title":"FileIO.save","text":"save(filename, data...) saves the contents of a formatted file, trying to infer the format from filename.\nsave(Stream{format\"PNG\"}(io), data...) specifies the format directly, and bypasses the format query.\nsave(File{format\"PNG\"}(filename), data...) specifies the format directly, and bypasses the format query.\nsave(f, data...; options...) passes keyword arguments on to the saver.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.savestreaming","page":"Reference","title":"FileIO.savestreaming","text":"Some packages may implement a streaming API, where the contents of the file can be written in chunks, rather than all at once. These higher-level streams should accept formatted objects, like an image or chunk of video or audio.\n\nsavestreaming(filename, data...) saves the contents of a formatted file, trying to infer the format from filename.\nsavestreaming(File{format\"WAV\"}(filename)) specifies the format directly, and bypasses the format query.\nsavestreaming(Stream{format\"WAV\"}(io)) specifies the format directly, and bypasses the format query.\nsavestreaming(f, data...; options...) passes keyword arguments on to the saver.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FileIO.skipmagic-Tuple{Stream}","page":"Reference","title":"FileIO.skipmagic","text":"skipmagic(s::Stream)\n\nSets the position of s to be just after the magic bytes. For a plain IO object, you can use skipmagic(io, fmt).\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.stream-Tuple{Stream}","page":"Reference","title":"FileIO.stream","text":"stream(s)\n\nReturns the stream associated with Stream s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FileIO.unknown-Tuple{Union{Type, Formatted}}","page":"Reference","title":"FileIO.unknown","text":"unknown(f)\n\nReturns true if the format of f is unknown.\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"Reference","title":"Reference","text":"FileIO.info","category":"page"},{"location":"reference/#FileIO.info","page":"Reference","title":"FileIO.info","text":"info(fmt)\n\nReturns the magic bytes/extension information for fmt.\n\n\n\n\n\n","category":"function"},{"location":"#FileIO.jl","page":"Home","title":"FileIO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FileIO aims to provide a common framework for detecting file formats and dispatching to appropriate readers/writers.  The two core functions in this package are called load and save, and offer high-level support for formatted files (in contrast with julia's low-level read and write).  To avoid name conflicts, packages that provide support for standard file formats through functions named load and save are encouraged to register with FileIO.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install FileIO within Julia via","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"FileIO\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If your format has been registered, it might be as simple as","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FileIO\nobj = load(filename)","category":"page"},{"location":"","page":"Home","title":"Home","text":"to read data from a formatted file. FileIO will attempt to find an installed package capable of reading filename; if no such package is found, it will suggest an appropriate package for you to add. It doesn't even have to be a file; you can download the Julia logo with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using FileIO, HTTP\n\njulia> img = load(HTTP.URI(\"https://github.com/JuliaLang/julia-logo-graphics/raw/master/images/julia-logo-color.png\"));\n\njulia> typeof(img)\nMatrix{RGBA{N0f8}} (alias for Array{ColorTypes.RGBA{FixedPointNumbers.Normed{UInt8, 8}}, 2})","category":"page"},{"location":"","page":"Home","title":"Home","text":"Likewise, saving might be as simple as","category":"page"},{"location":"","page":"Home","title":"Home","text":"save(filename, obj)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also utilize a piping style to save values to files like this","category":"page"},{"location":"","page":"Home","title":"Home","text":"obj |> save(filename)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you just want to inspect a file to determine its format, then","category":"page"},{"location":"","page":"Home","title":"Home","text":"file = query(filename)\ns = query(io)   # io is a stream","category":"page"},{"location":"","page":"Home","title":"Home","text":"will return a File or Stream object that also encodes the detected file format.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sometimes you want to read or write files that are larger than your available memory, or might be an unknown or infinite length (e.g. reading an audio or video stream from a socket). In these cases it might not make sense to process the whole file at once, but instead process it a chunk at a time. For these situations FileIO provides the loadstreaming and savestreaming functions, which return an object that you can read or write, rather than the file data itself.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This would look something like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FileIO\naudio = loadstreaming(\"bigfile.wav\")\ntry\n    while !eof(audio)\n        chunk = read(audio, 4096) # read 4096 frames\n        # process the chunk\n    end\nfinally\n    close(audio)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"or use do syntax to auto-close the stream:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FileIO\nloadstreaming(\"bigfile.wav\") do audio\n    while !eof(audio)\n        chunk = read(audio, 4096) # read 4096 frames\n        # process the chunk\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that in these cases you may want to use read! with a pre-allocated buffer for maximum efficiency.","category":"page"},{"location":"#Supported-formats","page":"Home","title":"Supported formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The existing supported formats are summarized in the Registry table.","category":"page"},{"location":"#Supporting-new-formats","page":"Home","title":"Supporting new formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to extend FileIO's support for new formats, there are two separate steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Registering a new format with FileIO\nImplementing loaders/savers in your package","category":"page"},{"location":"","page":"Home","title":"Home","text":"These steps can be done in either order.","category":"page"},{"location":"registering/#Registering-a-new-format","page":"Registering a new format","title":"Registering a new format","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"You register a new format by adding","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"add_format(fmt, magic, extension, libraries...)","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"to FileIO's registry. It's generally best if you experiment with this locally and make sure everything works before submitting a pull request. You'll need to pkg> dev FileIO to make the required changes.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Before going into detail explaining the arguments of add_format, here is a real example that could be used to register an I/O package for one of the Netpbm image formats:","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"add_format(format\"PPMBinary\", \"P6\", \".ppm\", [:Netpbm => UUID(\"f09324ee-3d7c-5217-9330-fc30815ba969\")])","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Briefly, this indicates that files in this format typically have extension .ppm, the file contents typically start with \"P6\" (the byte sequence [0x50, 0x36]), and these files can be read and written by the Netpbm package. (The UUID is Julia's unique identifier for this registered package and can be obtained from the Project.toml file.)","category":"page"},{"location":"registering/#Argument-fmt","page":"Registering a new format","title":"Argument fmt","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"fmt is a DataFormat type, most conveniently created as format\"IDENTIFIER\". If this file format has not previously been supported, you can make up IDENTIFIER yourself–there is no external standard, this is just a \"tag\" used internally by FileIO and its support routines. You should generally choose something that makes it easy to guess what format it refers to. Examples of some existing fmts are:","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"format\"PNG\": the format for png image files\nformat\"HDF5\": the format for hierarchical data files v5","category":"page"},{"location":"registering/#Argument-magic","page":"Registering a new format","title":"Argument magic","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"magic typically contains the magic bytes that identify the format. While file format can sometimes be guessed from the extension (e.g., \"pic.png\" would likely be a PNG image file), fundamentally the name of the file is something that can be changed by the user, so it may have no relationship to the content of the file. Moreover, there are many examples in which two or more different formats use the same extension, leading to ambiguity about the nature of the file. Is a .gbv file a Genie Timeline file or a PCB CAD file? Is that .fst file an audio file, a puzzle game file, or an R serialized dataframe file?","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"To identify the file uniquely, good format designers will include \"magic bytes\" as part of the content of the file to ensure that one can recognize or validate the format of the file. Typically, these magic bytes are the first bytes in the file, although there are many exceptions.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"warning: Warning\nFormats that use common extensions (e.g., .out) and lack magic bytes cannot be registered with FileIO– permitting this would force us to choose one particular format above all others. In such cases, your package should provide its own I/O without using FileIO. To avoid name conflicts with FileIO, it may be best to avoid exporting names like load and save from your package; use module-qualifiers like MyPkg.load instead.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Some formats have multiple \"flavors\" of magic bytes (which might, for example, include a \"format version\" number); in such cases magic can be a list of byte sequences. In other cases, files cannot be identified by a specific set of bytes, but there's a pattern that can be exploited: magic can be a function that returns true or false depending on whether an I/O stream is consistent with the format.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Examples of magic bytes include:","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"GIF image files can have magic bytes corresponding to the ASCII characters in \"GIF87a\", i.e., [0x47, 0x49, 0x46, 0x38, 0x37, 0x61]. Alternatively, they might use \"GIF89a\", which signals a different version of the GIF format.\nPLY mesh files can come in two flavors, ASCII and binary. Their magic bytes are \"ply\\nformat ascii 1.0\" and \"ply\\nformat binary_little_endian 1.0\", respectively. These magic bytes are human-readable and span the first two lines of the file.\nBedGraph genomic data files do not have official magic bytes, but they do have a structure which can be fairly reliably recognized by a suitable detection function. (Though it would have made life far more straightforward if the creators of the format had just added some magic bytes!)","category":"page"},{"location":"registering/#Argument-extension","page":"Registering a new format","title":"Argument extension","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"This can be a string or list of strings. Each should start with '.'.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Example: the Nearly Raw Raster Data format uses [\".nrrd\",\".nhdr\"].","category":"page"},{"location":"registering/#Argument-libraries","page":"Registering a new format","title":"Argument libraries","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"This argument specifies the package or packages that can support input and/or output for the format. Each package specification should be of the form name => uuid, where name is the name of the package (encoded as a Symbol, e.g., :FeatherFiles) and uuid is the UUID from the package's Project.toml. The first-to-be listed package has highest priority; FileIO will try to use it to perform the requested operation, and move onto the next only if that fails. Failure might occur because the user does not have the package installed, or because the package's handler threw an error.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Some packages may only support specific forms of I/O, and can use LOAD and SAVE as specifiers for supported operations. Likewise, some packages rely on system libraries available only on certain platforms, and can include a platform specifier.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"If your package isn't (yet) registered, you can alternatively specify the handler as the module itself.  In such cases, your call to add_format will likely be made from within your module or at the Julia REPL rather than in FileIO's registry. An exception is MimeWriter, a sub-module of FileIO that can write a few MIME formats.","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"Here's a real-world example (contained in FileIO's src/registry.jl) for PNG:","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"add_format(\n    format\"PNG\",\n    UInt8[0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a],\n    \".png\",\n    [idImageIO],\n    [idQuartzImageIO, OSX],\n    [idImageMagick],\n    [MimeWriter, SAVE]\n)","category":"page"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"idImageIO, idQuartzImageIO, and idImageMagic are name => uuid pairs for three different packages. QuartzImageIO is available only on macOS (OSX). The MimeWriter module (which is internally accessible to FileIO) only supports output (SAVE), not input.","category":"page"},{"location":"registering/#Examples","page":"Registering a new format","title":"Examples","text":"","category":"section"},{"location":"registering/","page":"Registering a new format","title":"Registering a new format","text":"For further examples, users are encouraged to inspect FileIO's registry directly.","category":"page"}]
}
